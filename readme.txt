aaaaaa
bbbbbb
branch dev 
modified bug-101!!
11111xiugaila
#10 求斐波那序列  时间复杂度O(n),用循环的方式实现递归
#11 寻找寻找数组中的最小数字
#12 矩阵中的路径  回溯法
#13 机器人的路径  回溯法
#14 剪绳子 动态规划 /贪婪算法
#15 二进制中1的个数  位运算 ，把一个整数减去1，再与原整数与运算，会把原整数最右边的1变为0
chapter3
#16 数值的整数次方 实现类似pow的功能
#17 打印从1到最大的n位数  / 最大数问题/用char[] 数组来存储数字
#18 删除链表中一个节点   / 换一种思路，覆盖deleteNode,删deleteNode.next 节点
#18-2 删除链表中重复的数字
#19 正则表达式匹配 /含糊呀 
#20 表示数值的字符串啊 / 正则表达式
#21 调整数组顺序使奇数位于偶数前面 /快速排序/ 判断数字位于前/后部分的函数解耦出来
#22 链表中倒数地K个节点// 用 fast和slow指针，两个指针之间永远相隔K-1步，//  注意代码的鲁棒性，链表长度小于K ，链表为空。
#23 链表中环的入口 // 用fast和slow指针，fast一次两步，slow一次一步 //  判断是否有环（在环中某一点相遇），fast重置为开始出，step=1， 与slow相遇环入口处
#24 反转链表 / 采用倒插法
#25 合并两个排序的链表 / 迭代
#26 树的子结构 /step1: 判断是否含有子树的root step2: b判断是否包含有子树
#27 二叉树的镜像 / 采用先序遍历 依次交换root的左右子节点
#28 对称的二叉树 / 修改后的先序遍历（root，right left）,依次对比root1(正常先序) root2(修改后的先序)
#29 顺时针打印矩阵/ 1.先找到打印的起始点（stat,start） 2. 打印（stat,start）环（四个步骤）
#31 栈的压入，弹出序列 / 利用一个辅助栈模拟进栈，每入栈一个判断是否与出栈相等（相等的话，
	执行出栈），最后判断栈是否为空 
#32 从上打印二叉树[二叉树的层次遍历] / 用一个队列实现，queue.size()为每一层的结点个数
#33 二叉树的后序遍历  /  根据根结点的值找出左子树，并判断右子树的值是否满足， 在依次递归左右子树  返回父节点时 return(left & right)